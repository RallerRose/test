#include <Arduino.h>

/************* Pins *************/
// Front
const int trigPinFront = 18;
const int echoPinFront = 35;   // INPUT-only (ESP32)

// Venstre (NY – 90° mod væg)
const int trigPinLeft90 = 4;   // TRIG (OUTPUT)
const int echoPinLeft90 = 34;  // INPUT-only (ESP32, 3.3V max)

// (Valgfrie/log pins — ikke brugt i styring, men beholdes)
const int trigPinLeft  = 17;
const int echoPinLeft  = 16;
const int trigPinRight = 23;
const int echoPinRight = 22;

// Motorer (L298N / H-bridge)
const int ENA = 26;  // Højre PWM
const int IN1 = 14;  // Højre retning
const int IN2 = 12;  // (strap-pin på nogle ESP32 — hold lav ved boot)
const int ENB = 25;  // Venstre PWM
const int IN3 = 27;  // Venstre retning
const int IN4 = 13;

// Encodere (LM393)
const int encLeftPin  = 32;  // venstre hjul
const int encRightPin = 33;  // højre hjul

/************* Parametre *************/
const int TARGET_SIDE_CM   = 10; // ønsket afstand til venstre væg
const int FRONT_TURN_CM    = 15; // under dette → 90° højresving
const int FRONT_SLOW_CM    = 30; // under dette → skaler basisfart
const int MAX_PWM          = 255;

// Små faste trims (gør højre lidt langsommere)
const int LEFT_TRIM  = 0;
const int RIGHT_TRIM = 8;   // 5–12 typisk

// Grundhastigheder
int baseLeft  = 140;
int baseRight = 145;

// Sidekorrektion (P)
// Sidekorrektion (PD i stedet for ren P)
float Kp = 4.5f;     // var 3.0 — mere “bid”
float Kd = 2.0f;     // ny D-led, dæmper zig-zag
const int CORR_MAX = 80; // var 50 — tillad større drejekorrektion


/************* Geometri til 90°-sving *************/
const float wheelDiameter_mm = 65.0f;
const float ticksPerRev      = 40.0f;        // sæt korrekt for jeres encoder
const float TRACK_MM         = 120.0f;       // mål hjulafstand (midt–midt)
const float mmPerTick        = (PI * wheelDiameter_mm) / ticksPerRev;
// Teori: arc for 90° pivot = pi*TRACK/4
const int   TICKS_TURN_90    = (int)round((TRACK_MM / (4.0f * wheelDiameter_mm)) * ticksPerRev);

/************* Encoder / hastighed *************/
volatile uint32_t ticksL = 0, ticksR = 0;
volatile uint32_t lastTickL_us = 0, lastTickR_us = 0;
const uint32_t minTickSpacingUs = 300;

unsigned long lastSpeedMs = 0;
uint32_t prevTL = 0, prevTR = 0;
float vL_f = 0, vR_f = 0;
const float VEL_ALPHA = 0.5f;

// PI-match (gør venstre/højre lige hurtige)
float Kv = 3.0f;   // P-gain (cm/s → PWM)
float Ki = 0.8f;   // I-gain
float bias = 0.0f; // +bias: højre er hurtigere → træk fra højre, læg til venstre
const float BIAS_MAX = 25.0f;
const int   BIAS_SLEW = 5;

/************* Utils *************/
int clamp(int v, int lo, int hi){ return v<lo?lo:(v>hi?hi:v); }
int slew(int cur, int tgt, int step){ if (tgt>cur) return min(tgt,cur+step); if (tgt<cur) return max(tgt,cur-step); return cur; }

/************* Encoders ISR *************/
void IRAM_ATTR isrEncLeft()  {
  uint32_t n = micros();
  if (n - lastTickL_us >= minTickSpacingUs) { ticksL++; lastTickL_us = n; }
}
void IRAM_ATTR isrEncRight() {
  uint32_t n = micros();
  if (n - lastTickR_us >= minTickSpacingUs) { ticksR++; lastTickR_us = n; }
}

/************* Ultralyd *************/
int readUltrasonicCM(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(8);
  digitalWrite(trigPin, LOW);
  unsigned long us = pulseIn(echoPin, HIGH, 30000UL);
  if (us == 0) return 400;       // intet ekko
  return (int)((us * 0.5f) / 29.412f + 0.5f);
}

/************* Motorstyring (uden LEDC) *************/
void setRightMotor(int pwm, bool forward) {
  pwm = clamp(pwm, 0, MAX_PWM);
  // retning
  digitalWrite(IN1, forward ? LOW : HIGH);
  digitalWrite(IN2, forward ? HIGH : LOW);
  // hastighed
  analogWrite(ENA, pwm);
}
void setLeftMotor(int pwm, bool forward) {
  pwm = clamp(pwm, 0, MAX_PWM);
  // retning (venstre er “inverteret” ift. højre i dit setup)
  digitalWrite(IN3, forward ? HIGH : LOW);
  digitalWrite(IN4, forward ? LOW  : HIGH);
  analogWrite(ENB, pwm);
}
void stopAll() {
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // valgfri bremse:
  // digitalWrite(IN1, HIGH); digitalWrite(IN2, HIGH);
  // digitalWrite(IN3, HIGH); digitalWrite(IN4, HIGH);
}

/************* Køre-funktioner *************/
void forwardDrive(int pwmL, int pwmR) {
  setLeftMotor (pwmL, true);
  setRightMotor(pwmR, true);
}
void spinRight(int pwm = 170) {  // venstre frem, højre tilbage
  setLeftMotor (pwm, true);
  setRightMotor(pwm, false);
}

/************* 90° højresving m. encodere *************/
void turnRight90() {
  bias = 0.0f;
  noInterrupts(); uint32_t startL = ticksL, startR = ticksR; interrupts();
  const int pwmTurn = 190;

  // start spin
  setLeftMotor (pwmTurn, true);   // venstre frem
  setRightMotor(pwmTurn, false);  // højre baglæns

  const uint32_t timeoutMs = 2500;
  uint32_t t0 = millis();
  while (true) {
    noInterrupts(); uint32_t dL = ticksL - startL, dR = ticksR - startR; interrupts();
    if (dL >= (uint32_t)TICKS_TURN_90 && dR >= (uint32_t)TICKS_TURN_90) break;
    if (millis() - t0 > timeoutMs) break;
    delay(5);
  }

  stopAll(); delay(60);

  // “fald i hak”
  forwardDrive(clamp(baseLeft, 80, 230), clamp(baseRight, 80, 230));
  delay(120);
}

/************* Hastigheds-PI (opdater ~10 Hz) *************/
void updateSpeedPI() {
  unsigned long now = millis();
  if (now - lastSpeedMs < 100) return;
  uint32_t dMs = now - lastSpeedMs; lastSpeedMs = now;

  noInterrupts(); uint32_t tL = ticksL, tR = ticksR; interrupts();
  uint32_t dTL = tL - prevTL, dTR = tR - prevTR; prevTL = tL; prevTR = tR;

  float vL = (dMs > 0) ? ((dTL * mmPerTick) / 10.0f) / (dMs / 1000.0f) : 0.0f;
  float vR = (dMs > 0) ? ((dTR * mmPerTick) / 10.0f) / (dMs / 1000.0f) : 0.0f;
  vL_f = (1.0f - VEL_ALPHA) * vL_f + VEL_ALPHA * vL;
  vR_f = (1.0f - VEL_ALPHA) * vR_f + VEL_ALPHA * vR;

  // eV > 0 ⇒ højre hurtigere end venstre
  float eV = vR_f - vL_f;

  static float I = 0.0f;
  I += eV * (dMs / 1000.0f);
  float maxI = (BIAS_MAX) / max(0.001f, Ki);
  I = constrain(I, -maxI, maxI);

  float biasTarget = Kv * eV + Ki * I;
  biasTarget = constrain(biasTarget, -BIAS_MAX, BIAS_MAX);

  int cur = (int)round(bias);
  int tgt = (int)round(biasTarget);
  bias = (float)slew(cur, tgt, BIAS_SLEW);

  // Debug (valgfri)
  // Serial.printf("vR=%.1f vL=%.1f eV=%.2f bias=%.1f\n", vR_f, vL_f, eV, bias);
}

/************* Setup *************/
void setup() {
  Serial.begin(115200);

  // Sensorpins
  pinMode(trigPinFront, OUTPUT);
  pinMode(echoPinFront, INPUT);
  pinMode(trigPinLeft90, OUTPUT);
  pinMode(echoPinLeft90, INPUT);

  // (valgfri log)
  pinMode(trigPinLeft,  OUTPUT); pinMode(echoPinLeft,  INPUT);
  pinMode(trigPinRight, OUTPUT); pinMode(echoPinRight, INPUT);

  // Motorretning
  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);

  // Sørg for sikre niveauer ved boot (vigtigt for GPIO12)
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
  stopAll();
  delay(150);

  // Encodere
  pinMode(encLeftPin,  INPUT_PULLUP);
  pinMode(encRightPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encLeftPin),  isrEncLeft,  RISING);
  attachInterrupt(digitalPinToInterrupt(encRightPin), isrEncRight, RISING);

  lastSpeedMs = millis();

  Serial.println("Start OK (no LEDC)");
}

// --- PD-styring state ---
float prevErr = 0.0f;
unsigned long lastCtrlMs = 0;


/************* Loop *************/
void loop() {
  // 1) Læs sensorer
  int f = readUltrasonicCM(trigPinFront,  echoPinFront);
  int s = readUltrasonicCM(trigPinLeft90, echoPinLeft90);

  // 2) Kun 90° højresving når fronten er tæt
  if (f < FRONT_TURN_CM) {
    Serial.println("[TURN] 90 deg right");
    stopAll(); delay(40);
    turnRight90();
    return;
  }

  // 3) Opdater hastigheds-PI (holder den lige)
  updateSpeedPI();

  // 4) Evt. fartnedskalering hvis noget er foran (uden at bakke)
  if (f < FRONT_SLOW_CM) {
    int lo = FRONT_TURN_CM, hi = FRONT_SLOW_CM;
    int cl = clamp(f, lo, hi);
    int minCruise = 100;
    int scale = minCruise + (int)((long)(cl - lo) * (max(baseLeft, baseRight) - minCruise) / (hi - lo));
    int baseL = clamp(scale, 80, 230);
    int baseR = clamp(scale, 80, 230);
  }

  
}
